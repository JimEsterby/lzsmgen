local cgen = {}

function cgen.base(file_basename)
	local delimiter
	local basename
	local reverse
	local delimiter_index
	local result

	-- distinguish between Linux and Windows
	--delimiter = package.config:sub(1,1)
	delimiter = "[\\/]"  -- Both Windows and Linux delimiters

	-- I need the last instance of the delimiter but lua is missing string.rfind
	reverse = string.reverse(file_basename)
	delimiter_index = string.find(reverse, delimiter)
	if delimiter_index then
		basename = string.sub(reverse, 1, delimiter_index - 1)
		basename = string.reverse(basename)
	else  -- bare file name without delimiters
		basename = file_basename
	end

	if string.find(basename, "[^%w_]") then
		result = false
	elseif string.find(basename, "[%w_]") == nil then
		result = false
	else
		result = true
		cgen.state_type = basename .. "_state_t"
		cgen.transition_type = basename .. "_transition_t"
	end

	return result, basename
end

function cgen.write_header(file_basename)
	local f
	local basename
	local result

	result, basename = cgen.base(file_basename)

	if result == false then
		return false
	end

	-- Open and write to file
	f = io.open(file_basename .. ".h", "w")
	if io.type(f) == "file" then
		-- Add the boilerplate stuff
		f:write("// Generated by lzsmgen on " .. os.date() .. "\n")
		f:write("#ifndef " .. string.upper(basename) .. "_H\n")
		f:write("#define " .. string.upper(basename) .. "_H\n\n")
		f:write("#include <stdint.h>\n\n")

		-- Define the structures
		f:write("typedef struct tag_" .. basename .. "_state ")
		f:write("*" .. basename .. "_state_p;\n\n")
		-- Transition structure
		f:write("typedef struct\n")
		f:write("{\n    uint8_t (*event)(void);\n    void (*action)(void);\n")
		f:write("    " .. basename .. "_state_p dest;\n} ")
		f:write(basename .. "_transition_t;\n\n")
		-- State structure
		f:write("typedef struct tag_" .. basename .. "_state\n{\n")
		f:write("    " .. basename .. "_state_p super;\n")
		f:write("    void (*during)(void);\n")
		f:write("    void (*entry)(void);\n")
		f:write("    " .. basename .. "_transition_t **out_matrix;\n} ")
		f:write(basename .. "_state_t;\n\n")

		-- Function prototypes
		f:write(basename .. "_state_t *" .. basename .. "_step(")
		f:write(basename .. "_state_t *current_state);\n")
		f:write(basename .. "_state_t *initialize_" .. basename .. "(void)\n")

		f:close()
		result = true
	else
		print("Error: Write to file failure\n")
	end

	return result
end

function cgen.open_src(file_basename)
	local f = io.open(file_basename .. ".c", "w")
	local result = false

	if io.type(f) == "file" then
		result = true
		cgen.src_file = f
		f:write("// Generated by lzsmgen on " .. os.date() .. "\n")
	end

	return result
end

function cgen.close_src()
	local f = cgen.src_file
	if f ~= nil then
		f:close()
	end
end

function cgen.includes(file_basename)
	local result
	local basename
	result, basename = cgen.base(file_basename)

	if result == true then
		local f = cgen.src_file

		f:write("#include <stdlib.h>\n")
		f:write("#include \"" .. basename .. ".h\"\n\n")
	end
end

function cgen.action_proto(base, suffix)
	local f = cgen.src_file

	f:write("static void " .. base .. "_" .. suffix .. "(void);\n")
end

function cgen.action_def(base, suffix, text)
	local f = cgen.src_file

	f:write("static void " .. base .. "_" .. suffix .. "(void)\n{\n")
	f:write(text .. "\n}\n\n")
end

function cgen.transition_event_proto(base)
	local f = cgen.src_file

	f:write("static uint8_t " .. base .. "_event(void);\n")
end

function cgen.transition_event_def(base, text)
	local f = cgen.src_file

	f:write("static uint8_t " .. base .. "_event(void)\n{\n")
	f:write("return ( " .. text .. " )\n}\n\n")
end

function cgen.write_text(text)
	cgen.src_file:write(text)
end

function cgen.declare_transition(name)
	cgen.src_file:write("static " .. cgen.transition_type .. " " .. name ..";\n")
end

function cgen.declare_state(name)
	cgen.src_file:write("static " .. cgen.state_type .. " " .. name ..";\n")
end

function cgen.begin_tr_matrix(name)
	cgen.src_file:write("static " .. cgen.transition_type .. " *" .. name)
	cgen.src_file:write("_mat[] =\n{\n")
end

function cgen.tr_matrix_add(name)
	cgen.src_file:write("    &" .. name .. ",\n")
end

function cgen.end_tr_matrix()
	cgen.src_file:write("    NULL\n};\n\n")
end

select_transition = [[
{
    /* super state transitions get higher priority */
    if (state->super)
    {
        transition = select_transition(state->super);
    }

    if (transition == NULL)
    {
        uint8_t i;

        for (i = 0; state->out_matrix[i] != NULL; i++)
        {
            /* if the event trigger has occurred...*/
            if (state->out_matrix[i]->event())
            {
                transition = out_matrix[i];
                break;
            }
        }
    }

    return transition;
}
]]

entry_code = [[
{
    if (dest->super != NULL && origin == NULL)
    {
        execute_entry_action(dest->super, NULL);
    }
    else if (dest->super != NULL && dest->super != origin->super)
    {
        execute_entry_action(dest->super, origin->super);
    }
    
    if (dest->entry)
    {
        dest->entry();
    }
}
]]

return cgen
