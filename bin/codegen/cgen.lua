local cgen = {}

function cgen.base(file_basename)
	local delimiter
	local basename
	local reverse
	local delimiter_index
	local result

	-- distinguish between Linux and Windows
	--delimiter = package.config:sub(1,1)
	delimiter = "[\\/]"  -- Both Windows and Linux delimiters

	-- I need the last instance of the delimiter but lua is missing string.rfind
	reverse = string.reverse(file_basename)
	delimiter_index = string.find(reverse, delimiter)
	if delimiter_index then
		basename = string.sub(reverse, 1, delimiter_index - 1)
		basename = string.reverse(basename)
	else  -- bare file name without delimiters
		basename = file_basename
	end

	if string.find(basename, "[^%w_]") then
		result = false
	elseif string.find(basename, "[%w_]") == nil then
		result = false
	else
		result = true
		cgen.state_type = basename .. "_state_t"
		cgen.transition_type = basename .. "_transition_t"
	end

	return result, basename
end

function cgen.write_header(file_basename)
	local f
	local basename
	local result

	result, basename = cgen.base(file_basename)

	if result == false then
		return false
	end

	-- Open and write to file
	f = io.open(file_basename .. ".h", "w")
	if io.type(f) == "file" then
		-- Add the boilerplate stuff
		f:write("// Generated by lzsmgen on " .. os.date() .. "\n")
		f:write("#ifndef " .. string.upper(basename) .. "_H\n")
		f:write("#define " .. string.upper(basename) .. "_H\n\n")
		f:write("#include <stdint.h>\n\n")

		-- Define the structures
		f:write("typedef struct tag_" .. basename .. "_state ")
		f:write("*" .. basename .. "_state_p;\n\n")
		-- Transition structure
		f:write("typedef struct\n")
		f:write("{\n    uint8_t (*event)(void);\n    void (*action)(void);\n")
		f:write("    " .. basename .. "_state_p dest;\n} ")
		f:write(basename .. "_transition_t;\n\n")
		-- State structure
		f:write("typedef struct tag_" .. basename .. "_state\n{\n")
		f:write("    " .. basename .. "_state_p super;\n")
		f:write("    void (*during)(void);\n")
		f:write("    void (*entry)(void);\n")
		f:write("    " .. basename .. "_transition_t **out_matrix;\n} ")
		f:write(basename .. "_state_t;\n\n")

		-- Function prototypes
		f:write(basename .. "_state_t *" .. basename .. "_step(")
		f:write(basename .. "_state_t *current_state);\n")
		f:write(basename .. "_state_t *initialize_" .. basename .. "(void)\n")

		f:close()
		result = true
	else
		print("Error: Write to file failure\n")
	end

	return result
end

function cgen.open_src(file_basename)
	local f = io.open(file_basename .. ".c", "w")
	local result = false

	if io.type(f) == "file" then
		result = true
		cgen.src_file = f
		f:write("// Generated by lzsmgen on " .. os.date() .. "\n")
	end

	return result
end

function cgen.close_src()
	local f = cgen.src_file
	if f ~= nil then
		f:close()
	end
end

function cgen.includes(file_basename)
	local result
	local basename
	result, basename = cgen.base(file_basename)

	if result == true then
		local f = cgen.src_file

		f:write("#include <stdlib.h>\n")
		f:write("#include \"" .. basename .. ".h\"\n\n")
	end
end

function cgen.action_proto(base, suffix)
	local f = cgen.src_file

	f:write("static void " .. base .. "_" .. suffix .. "(void);\n")
end

function cgen.action_def(base, suffix, text)
	local f = cgen.src_file

	f:write("static void " .. base .. "_" .. suffix .. "(void)\n{\n")
	f:write(text .. "\n}\n\n")
end

function cgen.transition_event_proto(base)
	local f = cgen.src_file

	f:write("static uint8_t " .. base .. "_event(void);\n")
end

function cgen.transition_event_def(base, text)
	local f = cgen.src_file

	f:write("static uint8_t " .. base .. "_event(void)\n{\n")
	f:write("return ( " .. text .. " );\n}\n\n")
end

-- Write miscellaneous text to the code
function cgen.write_text(text)
	cgen.src_file:write(text)
end

function cgen.declare_transition(name)
	cgen.src_file:write("static " .. cgen.transition_type .. " " .. name ..";\n")
end

function cgen.declare_state(name)
	cgen.src_file:write("static " .. cgen.state_type .. " " .. name ..";\n")
end

-- The following three methods used to build the transition matrices
function cgen.begin_tr_matrix(name)
	cgen.src_file:write("static " .. cgen.transition_type .. " *" .. name)
	cgen.src_file:write("_mat[] =\n{\n")
end

function cgen.tr_matrix_add(name)
	cgen.src_file:write("    &" .. name .. ",\n")
end

function cgen.end_tr_matrix()
	cgen.src_file:write("    NULL\n};\n\n")
end

-- Start defining the initialization function
function cgen.define_init_begin(file_basename)
	local result
	local base
	result, base = cgen.base(file_basename)

	if result == true then
		local f = cgen.src_file

		f:write(cgen.state_type .. " *initialize_" .. base .. "(void)\n{\n")
		f:write("    /* initialize transitions */\n")
	end
end

function cgen.init_transition(name, action, new_state)
	local l_action
	local l_state

	if action == nil then
		l_action = "NULL"
	else
		l_action = name .. "_" .. action
	end

	if new_state == nil then
		l_state = NULL  -- Note: This is a diagram error
	else
		l_state = "&" .. new_state
	end

	cgen.src_file:write("    " .. name .. ".action = " .. l_action .. ";\n")
	cgen.src_file:write("    " .. name .. ".event = " .. name .. "_event;\n")
	cgen.src_file:write("    " .. name .. ".dest = " .. l_state .. ";\n\n")
end

function cgen.init_state(name, super, during, entry)
	local l_super
	local l_during
	local l_entry

	if super == nil then l_super = "NULL" else l_super = "&" .. super end
	if during == nil then
		l_during = "NULL"
	else
		l_during = name .. "_" .. during
	end
	if entry == nil then
		l_entry = "NULL"
	else
		l_entry = name .. "_" .. entry
	end

	cgen.src_file:write("    " .. name .. ".super = " .. l_super .. ";\n")
	cgen.src_file:write("    " .. name .. ".during = " .. l_during .. ";\n")
	cgen.src_file:write("    " .. name .. ".entry = " .. l_entry .. ";\n")
	cgen.src_file:write("    " .. name .. ".out_matrix = " .. name .. "_mat;\n\n")
end

function cgen.complete_init_function(start)
	if start == nil then
		cgen.src_file:write("    return NULL;\n}\n\n")
	else
		cgen.src_file:write("    return &" .. start .. ";\n}\n\n")
	end
end


select_transition = [[
    /* super state transitions get higher priority */
    if (state->super)
    {
        transition = select_transition(state->super);
    }

    if (transition == NULL)
    {
        uint8_t i;

        for (i = 0; state->out_matrix[i] != NULL; i++)
        {
            /* if the event trigger has occurred...*/
            if (state->out_matrix[i]->event())
            {
                transition = state->out_matrix[i];
                break;
            }
        }
    }

    return transition;
}

]]

entry_code = [[
{
    if (dest->super != NULL && origin == NULL)
    {
        execute_entry_action(dest->super, NULL);
    }
    else if (dest->super != NULL && dest->super != origin->super)
    {
        execute_entry_action(dest->super, origin->super);
    }

    if (dest->entry)
    {
        dest->entry();
    }
}
]]

during_code = [[
{
    if (state->super)
    {
        execute_do_action(state->super);
    }

    if (state->during)
    {
        state->during();
    }
}

]]

step_code = [[

    execute_do_action(current);

    transition = select_transition(current);

    if (transition)
    {
        if (transition->action)
        {
            transition->action();
        }

        execute_entry_action(transition->dest, current);
        next = transition->dest;
    }

    return next;
}
]]

function cgen.write_selection_transition()
	cgen.src_file:write("static " .. cgen.transition_type)
	cgen.src_file:write(" *select_transition(" .. cgen.state_type .. " *state)\n{\n")
	cgen.src_file:write("    " .. cgen.transition_type .. " *transition = NULL;\n\n")
	cgen.src_file:write(select_transition)
end

function cgen.write_exec_entry()
	cgen.src_file:write("static void execute_entry_action(")
	cgen.src_file:write(cgen.state_type .. " *dest, " .. cgen.state_type .. " *origin)\n")
	cgen.src_file:write(entry_code)
end

function cgen.write_exec_during()
	cgen.src_file:write("static void execute_do_action(" .. cgen.state_type)
	cgen.src_file:write(" *state)\n")
	cgen.src_file:write(during_code)
end

function cgen.write_step(file_basename)
	local result
	local base
	result, base = cgen.base(file_basename)

	if result == true then
		local f = cgen.src_file

		f:write(cgen.state_type .. " *" .. base .. "_step(" .. cgen.state_type)
		f:write(" *current)\n{\n    ")
		f:write(cgen.state_type .. " *next = current;\n    ")
		f:write(cgen.transition_type .. " *transition = NULL;\n")
		f:write(step_code)
	end
end

return cgen
